{"version":3,"sources":["../src/utils/serialize.ts","../src/utils/deserialize.ts","../src/index.ts"],"names":["serialize","input","meta","seen","pathKey","path","walk","value","v","i","k","out","key","val","json","deserialize","data","values","refs","m","type","refPath","lastSlash","body","flags","set","map","arr","obj","newPath","stringify","parse"],"mappings":"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","file":"index.js","sourcesContent":["/* -------------------SERIALIZE------------------- */\r\n\r\nimport { MetaValues, Serialized } from \"../types/types\";\r\n\r\nexport function serialize<T>(input: T): Serialized<T> {\r\n  const meta: MetaValues = {};\r\n  const seen = new WeakMap<object, string[]>();\r\n\r\n  function pathKey(path: string[]) {\r\n    return path.join(\".\");\r\n  }\r\n\r\n  function walk(value: any, path: string[] = []): any {\r\n    // Circular reference\r\n    if (value && typeof value === \"object\") {\r\n      if (seen.has(value)) {\r\n        meta[pathKey(path)] = [\"Ref\", pathKey(seen.get(value)!)];\r\n        return null;\r\n      }\r\n      seen.set(value, path);\r\n    }\r\n\r\n    // undefined\r\n    if (value === undefined) {\r\n      meta[pathKey(path)] = [\"Undefined\"];\r\n      return null;\r\n    }\r\n\r\n    // Numbers\r\n    if (typeof value === \"number\") {\r\n      if (Number.isNaN(value)) {\r\n        meta[pathKey(path)] = [\"NaN\"];\r\n        return null;\r\n      }\r\n      if (value === Infinity) {\r\n        meta[pathKey(path)] = [\"Infinity\"];\r\n        return null;\r\n      }\r\n      if (value === -Infinity) {\r\n        meta[pathKey(path)] = [\"-Infinity\"];\r\n        return null;\r\n      }\r\n      if (Object.is(value, -0)) {\r\n        meta[pathKey(path)] = [\"-0\"];\r\n        return 0;\r\n      }\r\n      return value;\r\n    }\r\n\r\n    // BigInt\r\n    if (typeof value === \"bigint\") {\r\n      meta[pathKey(path)] = [\"BigInt\"];\r\n      return value.toString();\r\n    }\r\n\r\n    // Symbol\r\n    if (typeof value === \"symbol\") {\r\n      meta[pathKey(path)] = [\"Symbol\"];\r\n      return value.description ?? \"\";\r\n    }\r\n\r\n    // Date\r\n    if (value instanceof Date) {\r\n      meta[pathKey(path)] = [\"Date\"];\r\n      return value.toISOString();\r\n    }\r\n\r\n    // RegExp\r\n    if (value instanceof RegExp) {\r\n      meta[pathKey(path)] = [\"RegExp\"];\r\n      return value.toString();\r\n    }\r\n\r\n    // Set\r\n    if (value instanceof Set) {\r\n      meta[pathKey(path)] = [\"Set\"];\r\n      return Array.from(value).map((v, i) => walk(v, [...path, String(i)]));\r\n    }\r\n\r\n    // Map\r\n    if (value instanceof Map) {\r\n      meta[pathKey(path)] = [\"Map\"];\r\n      return Array.from(value.entries()).map(([k, v], i) => [\r\n        walk(k, [...path, \"k\", String(i)]),\r\n        walk(v, [...path, \"v\", String(i)])\r\n      ]);\r\n    }\r\n\r\n    // Array\r\n    if (Array.isArray(value)) {\r\n      return value.map((v, i) => walk(v, [...path, String(i)]));\r\n    }\r\n\r\n    // Object\r\n    if (value && typeof value === \"object\") {\r\n      const out: any = {};\r\n      for (const [key, val] of Object.entries(value)) {\r\n        out[key] = walk(val, [...path, key]);\r\n      }\r\n      return out;\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  const json = walk(input);\r\n\r\n  return Object.keys(meta).length\r\n    ? { json, meta: { values: meta, v: 1 } }\r\n    : { json };\r\n}\r\n","/* -------------------DESERIALIZE------------------- */\r\n\r\nimport { Serialized } from \"../types/types\";\r\nexport function deserialize<T>(data: Serialized<T>): T {\r\n    const { json, meta } = data;\r\n    const values = meta?.values ?? {};\r\n    const refs = new Map<string, any>();\r\n\r\n    function walk(value: any, path: string): any {\r\n        const m = values[path];\r\n\r\n        if (m) {\r\n            const [type, refPath] = m;\r\n\r\n            switch (type) {\r\n                case \"Ref\":\r\n                    return refs.get(refPath);\r\n\r\n                case \"Undefined\":\r\n                    return undefined;\r\n\r\n                case \"NaN\":\r\n                    return NaN;\r\n\r\n                case \"Infinity\":\r\n                    return Infinity;\r\n\r\n                case \"-Infinity\":\r\n                    return -Infinity;\r\n\r\n                case \"-0\":\r\n                    return -0;\r\n\r\n                case \"BigInt\":\r\n                    return BigInt(value);\r\n\r\n                case \"Date\":\r\n                    return new Date(value);\r\n\r\n                case \"Symbol\":\r\n                    return Symbol(value);\r\n\r\n                case \"RegExp\": {\r\n                    const lastSlash = value.lastIndexOf(\"/\");\r\n                    const body = value.slice(1, lastSlash);\r\n                    const flags = value.slice(lastSlash + 1);\r\n                    return new RegExp(body, flags);\r\n                }\r\n\r\n                case \"Set\": {\r\n                    const set = new Set(\r\n                        value.map((v: any, i: number) =>\r\n                            walk(v, path ? `${path}.${i}` : `${i}`)\r\n                        )\r\n                    );\r\n                    refs.set(path, set);\r\n                    return set;\r\n                }\r\n\r\n                case \"Map\": {\r\n                    const map = new Map(\r\n                        value.map(([k, v]: any, i: number) => [\r\n                            walk(k, `${path}.k.${i}`),\r\n                            walk(v, `${path}.v.${i}`)\r\n                        ])\r\n                    );\r\n                    refs.set(path, map);\r\n                    return map;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (Array.isArray(value)) {\r\n            const arr = value.map((v, i) =>\r\n                walk(v, path ? `${path}.${i}` : `${i}`)\r\n            );\r\n            refs.set(path, arr);\r\n            return arr;\r\n        }\r\n\r\n        if (value && typeof value === \"object\") {\r\n            const obj: any = {};\r\n            refs.set(path, obj);\r\n            for (const [key, val] of Object.entries(value)) {\r\n                const newPath = path ? `${path}.${key}` : key;\r\n                obj[key] = walk(val, newPath);\r\n            }\r\n            return obj;\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    return walk(json, \"\") as T;\r\n}","import { serialize } from \"./utils/serialize\";\r\nimport { deserialize } from \"./utils/deserialize\";\r\n\r\nexport function stringify<T>(value: T): string {\r\n  return JSON.stringify(serialize(value));\r\n}\r\n\r\nexport function parse<T>(value: string): T {\r\n  return deserialize(JSON.parse(value));\r\n}\r\n\r\nexport { serialize, deserialize };\r\n"]}